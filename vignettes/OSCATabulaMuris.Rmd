---
title: "OSCA Tabula Muris Analysis"
author: "Generated by Assistant"
date: "`r Sys.Date()`"
output: html_document
---

# Introduction

This document provides an analysis pipeline for Tabula Muris data using various R packages for single-cell RNA sequencing. Each chunk is annotated with a description of its purpose.

```{r setup, include=FALSE}
# Setup chunk: Load required libraries and set global options
knitr::opts_chunk$set(echo = TRUE)
```

## Load Required Libraries

The following libraries are loaded for data quality control, visualization, and analysis:

```{r load-libraries}
# Load necessary libraries for single-cell RNA-seq analysis
library(scater) # Data quality control and visualization
library(M3Drop) # Implements feature selection methods
library(Seurat) # Complete data analysis: QC, clustering, and exploration
library(mclust) # Metrics for clustering validation
library(scran) # Data preprocessing and normalization
library(SC3) # Clustering of scRNAseq data
library(SingleCellExperiment) # Core class for single-cell data
library(BiocParallel) # Parallel computation
library(HDF5Array) # Efficient storage and retrieval of HDF5 files
```

## Load Data

```{r}
# Read data
tabData <- readRDS("~/Downloads/Subsemple1percentemptyDroplets_doublet_filtered_tabulamuris_mtx.rds")
datav2 <- system.file("extdata", "Subsemple1percentemptyDroplets_doublet_filtered_tabulamuris_mtx.rds", package = "scrobinv2")
tabData <- readRDS(datav2)


# Read cell metadata 
inf <- system.file("extdata", "tabulamuris_cell_info.rds", package = "scrobinv2")
info1 <- readRDS(inf)
info <- subset(info1, id %in% colnames(tabData))
dim(info)
```

## Create a SingleCellExperiment Object

Combine the data into a SingleCellExperiment object for downstream analysis:

```{r create-sce}
# Create a SingleCellExperiment object
wrkrs <- 15 # Number of workers for parallelization
match_order <- match(colnames(tabData), rownames(info))
info <- info[match_order, ]
sce <- SingleCellExperiment(assays = list(counts = tabData), colData = info)
```

## Quality Control

Add quality control metrics to the SingleCellExperiment object:

```{r quality-control}
# Perform quality control and visualize cell metrics
sce <- addPerCellQC(sce)
hist(sce$total, breaks = 50, xlab = "Library Sizes", main = "Distribution of Library Sizes")
hist(sce$detected, xlab="Number of expressed genes", breaks=50,  ylab="Number of cells")

plotHighestExprs(sce, exprs_values = "counts")
```

## Filter Genes with Low Expression
Filter genes based on their average expression levels to exclude non-informative features.

```{r}
# Calculate average counts for each gene and filter out genes with zero average expression
rowData(sce)$ave.counts <- calculateAverage(sce, exprs_values = "counts", BPPARAM = MulticoreParam(workers = wrkrs))
to.keep <- rowData(sce)$ave.counts > 0
sce <- sce[to.keep, ]
summary(to.keep)  # Summary of genes kept
dim(sce)          # Dimensions of the filtered SingleCellExperiment object

```

## Normalize Counts
Normalize the data using scran's computeSumFactors and log-normalization for downstream analysis.
```{r}
# Compute size factors and normalize counts
library(scran)
set.seed(1000)
clusters <- quickCluster(sce, BPPARAM = MulticoreParam(workers = wrkrs))
sce <- computeSumFactors(sce, cluster = clusters, BPPARAM = MulticoreParam(workers = wrkrs))
sce <- logNormCounts(sce)

```

## Variance Modelling and Highly Variable Genes
Model variance to identify highly variable genes for downstream analysis.

```{r}
# Model variance and identify the top highly variable genes
set.seed(1001)
dec <- modelGeneVarByPoisson(sce, BPPARAM = MulticoreParam(workers = wrkrs))
top <- getTopHVGs(dec, prop = 0.1)

```

## Dimensionality Reduction
Perform PCA, t-SNE, and UMAP for dimensionality reduction to visualize the data in lower-dimensional spaces.
```{r}
# Perform PCA and reduce dimensions using t-SNE and UMAP
set.seed(10000)
sce <- denoisePCA(sce, subset.row = top, technical = dec, BPPARAM = MulticoreParam(workers = wrkrs))
ncol(reducedDim(sce))  # Number of principal components used

set.seed(100000)
sce <- runTSNE(sce, dimred = "PCA")

set.seed(1000000)
sce <- runUMAP(sce, dimred = "PCA")
plotReducedDim(sce, dimred = "UMAP", colour_by = "cell_ontology_class")  # Plot UMAP
```


## Graph Construction
Construct a shared nearest neighbor (SNN) graph based on PCA-reduced dimensions.

```{r}
# Build a shared nearest neighbor (SNN) graph
library(scran)
graph <- buildSNNGraph(sce, k = 25, use.dimred = 'PCA')  # k=25 neighbors

```



## Cluster Evaluation
Evaluate different clustering methods using robin

```{r}
# Simplify the graph and evaluate clustering methods
library(igraph)
graph <- igraph::simplify(graph)  # Simplify the graph by removing duplicate edges
```

## Robin
## Compare all algorithms vs Louvain
We apply the compare procedure to see which is the algorithm that better fits our network.
```{r}
library(robin)
graph <- prepGraph(graph, file.format="igraph")
#Infomap
 comp_I <- robinCompare(graph=graph, method1="louvain",
                        method2="infomap")
 plot1 <- plot(comp_I)


#Walktrap
comp_W <- robinCompare(graph=graph, method1="louvain",
                       method2="walktrap")

plot2 <- plot(comp_W)


#LabelProp
comp_La <- robinCompare(graph=graph, method1="louvain",
                        method2="labelProp")


plot3 <- plot(comp_La)

#Fastgreedy
comp_F <- robinCompare(graph=graph, method1="louvain",
                        method2="fastGreedy")

plot4 <- plot(comp_F)


PlotComparisonAllVsInfomap <- gridExtra::grid.arrange(plot1,plot2,plot3,plot4, ncol=2)

```


The lowest curve is the most stable algorithm. Louvain and Walktrap are the best algorithms in our example. 



## Statistical significance of communities

Due to the fact that Louvain is one of the best algorithm for our network we apply the robust procedure with the Louvain algorithm to see if the communities detected are statistically significant.

```{r}
graphRandom <- random(graph=graph)
proc <- robinRobust(graph=graph, graphRandom=graphRandom, method="louvain")

plot(proc)

robinFDATest(proc)

robinGPTest(proc)
```

The communities given by Louvain are statistically significant.

## Communities
```{r}
table(membershipCommunities (graph=graph, method="louvain"))

```

